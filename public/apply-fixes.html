<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WagYu Database Fixes</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      color: #6d28d9;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 10px;
    }
    .card {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
      border-left: 4px solid #6d28d9;
    }
    button {
      background-color: #6d28d9;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #5b21b6;
    }
    button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
    }
    .log {
      background-color: #f3f4f6;
      border-radius: 4px;
      padding: 12px;
      margin-top: 16px;
      font-family: monospace;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .error {
      color: #dc2626;
    }
    .success {
      color: #10b981;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <h1>WagYu Database Fixes</h1>
  
  <div class="card">
    <h2>Duration Type Fixes</h2>
    <p>This tool will fix the "CASE types text and interval cannot be matched" error that occurs when uploading Tradovate and TopstepX trades.</p>
    
    <div id="auth-section">
      <p>First, you need to authenticate with Supabase:</p>
      <div>
        <input type="email" id="email" placeholder="Email" />
        <input type="password" id="password" placeholder="Password" />
        <button id="login-btn">Login</button>
      </div>
      <div class="log" id="auth-log"></div>
    </div>
    
    <div id="fix-section" class="hidden">
      <p>You're authenticated. Click the buttons below to apply fixes:</p>
      
      <div>
        <button id="tradovate-btn">Fix Tradovate Import</button>
        <button id="topstepx-btn">Fix TopstepX Import</button>
        <button id="create-exec-sql-btn">Create exec_sql Function</button>
      </div>
      
      <div class="log" id="fix-log"></div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize Supabase client
      const supabaseUrl = 'https://wagyu.supabase.co';
      const supabaseAnonKey = ''; // This should be set from your .env or left blank for security
      
      if (!supabaseAnonKey) {
        console.warn('Supabase anon key not set! You will need to enter it manually or use a service that loads .env variables.');
      }
      
      const supabase = supabase.createClient(supabaseUrl, supabaseAnonKey);
      
      // DOM elements
      const authSection = document.getElementById('auth-section');
      const fixSection = document.getElementById('fix-section');
      const authLog = document.getElementById('auth-log');
      const fixLog = document.getElementById('fix-log');
      const loginBtn = document.getElementById('login-btn');
      const tradovateBtn = document.getElementById('tradovate-btn');
      const topstepxBtn = document.getElementById('topstepx-btn');
      const createExecSqlBtn = document.getElementById('create-exec-sql-btn');
      
      // Helper functions
      function log(element, message, type = 'info') {
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logEntry.classList.add(type);
        element.appendChild(logEntry);
        element.scrollTop = element.scrollHeight;
      }
      
      // Check if user is already logged in
      async function checkAuth() {
        const { data, error } = await supabase.auth.getSession();
        
        if (data?.session) {
          authSection.classList.add('hidden');
          fixSection.classList.remove('hidden');
          log(authLog, `Logged in as ${data.session.user.email}`, 'success');
        }
      }
      
      // Login handler
      loginBtn.addEventListener('click', async () => {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        
        if (!email || !password) {
          log(authLog, 'Please enter both email and password', 'error');
          return;
        }
        
        log(authLog, 'Logging in...');
        loginBtn.disabled = true;
        
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password
        });
        
        loginBtn.disabled = false;
        
        if (error) {
          log(authLog, `Login failed: ${error.message}`, 'error');
        } else {
          log(authLog, 'Login successful!', 'success');
          authSection.classList.add('hidden');
          fixSection.classList.remove('hidden');
        }
      });
      
      // Function to fetch SQL file content
      async function fetchSqlFile(filename) {
        try {
          const response = await fetch(`/scripts/${filename}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch ${filename}: ${response.statusText}`);
          }
          return await response.text();
        } catch (error) {
          log(fixLog, `Error fetching ${filename}: ${error.message}`, 'error');
          return null;
        }
      }
      
      // Apply SQL fix
      async function applySqlFix(sql, fixName) {
        log(fixLog, `Applying ${fixName}...`);
        
        try {
          const { data, error } = await supabase.rpc('exec_sql', { sql });
          
          if (error) {
            log(fixLog, `Error applying ${fixName}: ${error.message}`, 'error');
            return false;
          }
          
          log(fixLog, `${fixName} applied successfully!`, 'success');
          return true;
        } catch (error) {
          log(fixLog, `Exception applying ${fixName}: ${error.message}`, 'error');
          return false;
        }
      }
      
      // Tradovate fix button handler
      tradovateBtn.addEventListener('click', async () => {
        tradovateBtn.disabled = true;
        const sql = await fetchSqlFile('fix_tradovate_duration_type.sql');
        
        if (sql) {
          await applySqlFix(sql, 'Tradovate duration type fix');
        }
        
        tradovateBtn.disabled = false;
      });
      
      // TopstepX fix button handler
      topstepxBtn.addEventListener('click', async () => {
        topstepxBtn.disabled = true;
        const sql = await fetchSqlFile('fix_topstepx_duration_type.sql');
        
        if (sql) {
          await applySqlFix(sql, 'TopstepX duration type fix');
        }
        
        topstepxBtn.disabled = false;
      });
      
      // Create exec_sql function button handler
      createExecSqlBtn.addEventListener('click', async () => {
        createExecSqlBtn.disabled = true;
        const sql = await fetchSqlFile('create_exec_sql_function.sql');
        
        if (sql) {
          await applySqlFix(sql, 'exec_sql function creation');
        }
        
        createExecSqlBtn.disabled = false;
      });
      
      // Check if user is already authenticated
      checkAuth();
    });
  </script>
</body>
</html> 