//! Event types for the event-driven backtesting engine
//! 
//! Events flow through the system in this order:
//! MarketData → Signal → Order → Fill → PortfolioUpdate

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;

/// Unique identifier for events
pub type EventId = u64;

/// Trading direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    Buy,
    Sell,
}

impl Side {
    pub fn opposite(&self) -> Side {
        match self {
            Side::Buy => Side::Sell,
            Side::Sell => Side::Buy,
        }
    }
}

/// Order types supported by the engine
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderType {
    Market,
    Limit,
    Stop,
    StopLimit,
}

/// Order status in the lifecycle
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderStatus {
    Submitted,
    Pending,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
}

/// OHLCV bar data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bar {
    pub timestamp: DateTime<Utc>,
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

impl Bar {
    pub fn new(timestamp: DateTime<Utc>, open: f64, high: f64, low: f64, close: f64, volume: f64) -> Self {
        Self { timestamp, open, high, low, close, volume }
    }

    /// Get the typical price (HLC average)
    pub fn typical_price(&self) -> f64 {
        (self.high + self.low + self.close) / 3.0
    }

    /// Get the VWAP approximation for this bar
    pub fn vwap(&self) -> f64 {
        self.typical_price()
    }
}

/// Market data event containing OHLCV data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDataEvent {
    pub id: EventId,
    pub symbol: String,
    pub bar: Bar,
}

/// Trading signal generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalEvent {
    pub id: EventId,
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub signal: i32,  // -1 = sell, 0 = hold, 1 = buy
    pub strength: f64,  // Signal strength 0.0 to 1.0
    pub target_pct: Option<f64>,  // Target portfolio percentage
}

impl SignalEvent {
    pub fn buy(id: EventId, timestamp: DateTime<Utc>, symbol: String, strength: f64) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            signal: 1,
            strength,
            target_pct: None,
        }
    }

    pub fn sell(id: EventId, timestamp: DateTime<Utc>, symbol: String, strength: f64) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            signal: -1,
            strength,
            target_pct: None,
        }
    }

    pub fn hold(id: EventId, timestamp: DateTime<Utc>, symbol: String) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            signal: 0,
            strength: 0.0,
            target_pct: None,
        }
    }
}

/// Order event submitted to the broker
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderEvent {
    pub id: EventId,
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub order_type: OrderType,
    pub side: Side,
    pub quantity: f64,
    pub limit_price: Option<f64>,
    pub stop_price: Option<f64>,
    pub status: OrderStatus,
}

impl OrderEvent {
    pub fn market(
        id: EventId,
        timestamp: DateTime<Utc>,
        symbol: String,
        side: Side,
        quantity: f64,
    ) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            order_type: OrderType::Market,
            side,
            quantity,
            limit_price: None,
            stop_price: None,
            status: OrderStatus::Submitted,
        }
    }

    pub fn limit(
        id: EventId,
        timestamp: DateTime<Utc>,
        symbol: String,
        side: Side,
        quantity: f64,
        limit_price: f64,
    ) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            order_type: OrderType::Limit,
            side,
            quantity,
            limit_price: Some(limit_price),
            stop_price: None,
            status: OrderStatus::Submitted,
        }
    }

    pub fn stop(
        id: EventId,
        timestamp: DateTime<Utc>,
        symbol: String,
        side: Side,
        quantity: f64,
        stop_price: f64,
    ) -> Self {
        Self {
            id,
            timestamp,
            symbol,
            order_type: OrderType::Stop,
            side,
            quantity,
            limit_price: None,
            stop_price: Some(stop_price),
            status: OrderStatus::Submitted,
        }
    }
}

/// Fill event when an order is executed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FillEvent {
    pub id: EventId,
    pub order_id: EventId,
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub side: Side,
    pub quantity: f64,
    pub fill_price: f64,
    pub commission: f64,
    pub slippage: f64,
}

impl FillEvent {
    pub fn total_cost(&self) -> f64 {
        let base_cost = self.quantity * self.fill_price;
        match self.side {
            Side::Buy => base_cost + self.commission + self.slippage,
            Side::Sell => base_cost - self.commission - self.slippage,
        }
    }
}

/// Portfolio update event after fills are processed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortfolioUpdateEvent {
    pub id: EventId,
    pub timestamp: DateTime<Utc>,
    pub cash: f64,
    pub equity: f64,
    pub positions: Vec<(String, f64, f64)>,  // (symbol, quantity, avg_price)
    pub realized_pnl: f64,
    pub unrealized_pnl: f64,
}

/// Unified event enum for the event queue
#[derive(Debug, Clone)]
pub enum Event {
    MarketData(MarketDataEvent),
    Signal(SignalEvent),
    Order(OrderEvent),
    Fill(FillEvent),
    PortfolioUpdate(PortfolioUpdateEvent),
}

impl Event {
    pub fn timestamp(&self) -> DateTime<Utc> {
        match self {
            Event::MarketData(e) => e.bar.timestamp,
            Event::Signal(e) => e.timestamp,
            Event::Order(e) => e.timestamp,
            Event::Fill(e) => e.timestamp,
            Event::PortfolioUpdate(e) => e.timestamp,
        }
    }

    pub fn id(&self) -> EventId {
        match self {
            Event::MarketData(e) => e.id,
            Event::Signal(e) => e.id,
            Event::Order(e) => e.id,
            Event::Fill(e) => e.id,
            Event::PortfolioUpdate(e) => e.id,
        }
    }

    pub fn priority(&self) -> u8 {
        // Lower number = higher priority
        match self {
            Event::MarketData(_) => 0,
            Event::Signal(_) => 1,
            Event::Order(_) => 2,
            Event::Fill(_) => 3,
            Event::PortfolioUpdate(_) => 4,
        }
    }
}

impl PartialEq for Event {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl Eq for Event {}

impl PartialOrd for Event {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Event {
    fn cmp(&self, other: &Self) -> Ordering {
        // First by timestamp, then by priority
        match self.timestamp().cmp(&other.timestamp()) {
            Ordering::Equal => self.priority().cmp(&other.priority()),
            other => other,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bar_typical_price() {
        let bar = Bar::new(Utc::now(), 100.0, 110.0, 90.0, 105.0, 1000.0);
        assert!((bar.typical_price() - 101.67).abs() < 0.1);
    }

    #[test]
    fn test_fill_total_cost() {
        let fill = FillEvent {
            id: 1,
            order_id: 0,
            timestamp: Utc::now(),
            symbol: "BTC/USD".to_string(),
            side: Side::Buy,
            quantity: 1.0,
            fill_price: 50000.0,
            commission: 50.0,
            slippage: 25.0,
        };
        assert_eq!(fill.total_cost(), 50075.0);
    }

    #[test]
    fn test_event_ordering() {
        let now = Utc::now();
        let e1 = Event::MarketData(MarketDataEvent {
            id: 1,
            symbol: "BTC".to_string(),
            bar: Bar::new(now, 100.0, 100.0, 100.0, 100.0, 100.0),
        });
        let e2 = Event::Signal(SignalEvent::buy(2, now, "BTC".to_string(), 1.0));
        
        assert!(e1 < e2);  // MarketData has higher priority (lower number)
    }
}

